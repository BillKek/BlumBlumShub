using System;
using System.Net;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Numerics; // В проекте добавь ссылку\reference на модуль\dll "System.Numerics"

namespace ПространствоПотоковогоШифровщика
{
    partial class ПотоковыйШифровщикББШ // на базе Алгоритма Блюм — Блюма — Шуба.
    {
        private BigInteger ПростоеВМатСмыслеЧисло1;
        private BigInteger ПростоеВМатСмыслеЧисло2;
        private BigInteger МодульАлгоритма;
        private BigInteger АккумуляторАлгоритма;
        private BigInteger НачальныйАккумуляторАлгоритмаСкорректированный;
        private UInt64 МодульДляРасчётаТелепорта;

        public ПотоковыйШифровщикББШ(UInt64 ТелепортНаНомерВПоследовательностиБайт, UInt64 НачальныйАккумуляторАлгоритма)
        {
            ПростоеВМатСмыслеЧисло1 = BigInteger.Parse("982451579");
            ПростоеВМатСмыслеЧисло2 = BigInteger.Parse("982451567");            
            МодульАлгоритма = BigInteger.Multiply(ПростоеВМатСмыслеЧисло1, ПростоеВМатСмыслеЧисло2);
            МодульДляРасчётаТелепорта = НаименьшееОбщееКратное((UInt64)ПростоеВМатСмыслеЧисло1 - 1, (UInt64)ПростоеВМатСмыслеЧисло2 - 1);
            НачальныйАккумуляторАлгоритмаСкорректированный = КоррекцияНачальногоАккумулятораАлгоритма(НачальныйАккумуляторАлгоритма);

            ТелепортерНаНомерВПоследовательности(ТелепортНаНомерВПоследовательностиБайт);
        }

        public void ТелепортерНаНомерВПоследовательности(UInt64 ТелепортНаНомерВПоследовательностиБайт)
        {
            BigInteger СтепеньДляВычисленияАккумулятораПоНомеру;
            BigInteger ТелепортНаНомерВПоследовательностиБит = BigInteger.Multiply(ТелепортНаНомерВПоследовательностиБайт, (BigInteger)8);
            UInt64 ДобавкаДляПропускаНачальнойПоследовательности = (UInt64)МодульАлгоритма / 2; // пропуск начальной последовательности, где нету отсечения по модулю алгоритма
            ТелепортНаНомерВПоследовательностиБит = BigInteger.Add(ТелепортНаНомерВПоследовательностиБит, ДобавкаДляПропускаНачальнойПоследовательности);

            СтепеньДляВычисленияАккумулятораПоНомеру = BigInteger.ModPow(BigInteger.Parse("2"), ТелепортНаНомерВПоследовательностиБит, МодульДляРасчётаТелепорта);
            BigInteger АккумуляторПоНомеру;
            АккумуляторПоНомеру = BigInteger.ModPow(НачальныйАккумуляторАлгоритмаСкорректированный, СтепеньДляВычисленияАккумулятораПоНомеру, МодульАлгоритма);
            АккумуляторАлгоритма = АккумуляторПоНомеру;
        }

        private UInt64 КоррекцияНачальногоАккумулятораАлгоритма(UInt64 НачальныйАккумуляторАлгоритма)
        {
            UInt64 НачальныйАккумуляторАлгоритмаСкорректированный;
            UInt64 ТекущийНаибольшийОбщийДелитель;
            НачальныйАккумуляторАлгоритмаСкорректированный = НачальныйАккумуляторАлгоритма - 1;
            do
            {
                НачальныйАккумуляторАлгоритмаСкорректированный = НачальныйАккумуляторАлгоритмаСкорректированный + 1;
                НачальныйАккумуляторАлгоритмаСкорректированный = НачальныйАккумуляторАлгоритма % (UInt64)МодульАлгоритма;
                ТекущийНаибольшийОбщийДелитель = НаибольшийОбщийДелитель(НачальныйАккумуляторАлгоритмаСкорректированный, (UInt64)МодульАлгоритма);
            } while ( (ТекущийНаибольшийОбщийДелитель != 1) && (НачальныйАккумуляторАлгоритмаСкорректированный != 0) );
            return (НачальныйАккумуляторАлгоритмаСкорректированный);
        }

        private UInt64 НаибольшийОбщийДелитель(UInt64 НенулевоеЧислоНомер1, UInt64 НенулевоеЧислоНомер2)
        {
            while (НенулевоеЧислоНомер2 != 0)
            {
                UInt64 Временная = НенулевоеЧислоНомер2;
                НенулевоеЧислоНомер2 = НенулевоеЧислоНомер1 % НенулевоеЧислоНомер2;
                НенулевоеЧислоНомер1 = Временная;
            }
            return НенулевоеЧислоНомер1;
        }

        private bool ОдинШагАлгоритмаББШ()
        {
            АккумуляторАлгоритма = BigInteger.Multiply(АккумуляторАлгоритма, АккумуляторАлгоритма);
            АккумуляторАлгоритма = АккумуляторАлгоритма % МодульАлгоритма;
            if (((АккумуляторАлгоритма) % 2) == 0)
                return false;
            else
                return true;
        }

        private UInt64 НаименьшееОбщееКратное(UInt64 ПервоеЧисло, UInt64 ВтороеЧисло)
        {
            BigInteger ПервоеБольшоеЧисло = ПервоеЧисло;
            BigInteger ВтороеБольшоеЧисло = ВтороеЧисло;
            BigInteger НаибольшийОбщийДелительТут = НаибольшийОбщийДелитель(ПервоеЧисло,ВтороеЧисло);
            BigInteger Результат;
            BigInteger Произведение = BigInteger.Multiply(ПервоеБольшоеЧисло, ВтороеБольшоеЧисло);
            Результат = BigInteger.Divide(Произведение , НаибольшийОбщийДелительТут);
            return (UInt64)Результат;
        }
        public byte ПолучитьБайтББШ()
        {
            int Байт = 0;
            for (int i = 0; i < 8; i++)
            {
               if (ОдинШагАлгоритмаББШ())
                  Байт |= (1 << i);                
            }
            return (byte)Байт;
        }
    }
}



